struct no_t *tree_max(struct no_t *r){
    if(r == NULL) return NULL;

    while(r->dir != NULL){
        r = r->dir;
    }

    return r; 
}

void transplant(struct tree_t *t, struct no_t *u, struct no_t *v){
    fprintf(stderr, "Entrou transplante\n");
    //Se u for raiz, substitui por v
    if(u->pai == NULL){
        t->root = v;
        fprintf(stderr, "Caso 1\n");
    }
        
    //Se for o filho da esquerda    
    else if(u == u->pai->esq){
        fprintf(stderr, "Caso 2\n");
        u->pai->esq = v; //v serÃ¡ excluido
    }
    else {
        fprintf(stderr, "Caso 3\n");
        u->pai->dir = v;
    }
        
    
    if(v != NULL) //Se v era raiz
        v->pai = u->pai;
}

void remover_fixup(struct tree_t *t, struct no_t *x){
    fprintf(stderr, "Entrou no remove fixup\n");
   
    while(x != t->root && x->cor == BLACK){
        if(x == x->pai->esq){
            struct no_t *w = x->pai->dir;
            fprintf(stderr, "Caso 1a\n");
            //Caso 1
            if(w->cor == RED){
                w->cor = BLACK;
                x->pai->cor = RED;
                rot_esq(t, x->pai);
                w = x->pai->dir;
            }
            //Caso 2
            if(w->esq->cor == BLACK && w->dir->cor == BLACK){
                fprintf(stderr, "Caso 2a\n");
                w->cor = RED;
                x = x->pai;
            }
            //Caso 3
            else {
                if(w->dir->cor == BLACK){
                    fprintf(stderr, "Caso 3a\n");
                    w->esq->cor = BLACK;
                    w->cor = RED;
                    rot_dir(t, w);
                    w = x->pai->dir;
                }
                //Caso 
                fprintf(stderr, "Caso 4a\n");
                w->cor = x->pai->cor;
                x->pai->cor = BLACK;
                w->dir->cor = BLACK;
                rot_esq(t, x->pai);
                x = t->root;
            }
        }
        else{
            struct no_t *w = x->pai->esq;
            //Caso 1

            if(w->cor == RED){
                fprintf(stderr, "Caso 1b\n");
                x->cor = BLACK;
                x->pai->cor = RED;
                rot_dir(t, x->pai);
                w = x->pai->esq;
            }
            //Caso 2
            if(w->dir->cor == BLACK && w->esq->cor == BLACK){
                fprintf(stderr, "Caso 2b\n");
                w->cor = RED;
                x = x->pai;
            }
            //Caso 3
            else{
                if(w->esq->cor == BLACK){
                    fprintf(stderr, "Caso 3b\n");
                    w->dir->cor = BLACK;
                    w->cor = RED;
                    rot_esq(t, w);
                    w = x->pai->esq;
                }
                //Caso 4
                fprintf(stderr, "Caso 4b\n");
                w->cor = x->pai->cor;
                x->pai->cor = BLACK;
                w->esq->cor = BLACK;
                rot_dir(t, x->pai);
                x = t->root;
            }
        }
    }
    x->cor = BLACK;
}

void remover(struct tree_t *t, int chave){
    fprintf(stderr, "Entrou remover\n");
    struct no_t *z = busca(t->root, chave);

    if(z == NULL)
        return;

    struct no_t *y = z;
    struct no_t *x;
    int y_cor_orig = y->cor;

    if(z->esq == NULL){
        fprintf(stderr, "a\n");
        x = z->dir;
        if(z->pai == NULL)
            t->root = x;
        else if(z == z->pai->esq)
            z->pai->esq = x;
        else
            z->pai->dir = x;
        
        if (x != NULL)
            x->pai = z->pai;
    } else if(z->dir == NULL){
        fprintf(stderr, "b\n");
        x = z->esq;
        if(z->pai == NULL)
            t->root = x;
        else if(z == z->pai->esq)
            z->pai->esq = x;
        else
            z->pai->dir = x;

        if (x != NULL)
            x->pai = z->pai;
    } else {
        y = tree_max(z->esq);  
        fprintf(stderr, "c\n");
        y_cor_orig = y->cor;
        x = y->esq;

        if(y->pai != z){
            fprintf(stderr, "d\n");
            if(y == y->pai->esq)
                y->pai->esq = x;
            else
                y->pai->dir = x;

            if (x != NULL)
                x->pai = y->pai;

            y->esq = z->esq;
            if(y->esq != NULL)
                y->esq->pai = y;
        }
        fprintf(stderr, "e\n");
        if(z->pai == NULL)
            t->root = y;
        else if(z == z->pai->esq)
            z->pai->esq = y;
        else
            z->pai->dir = y;
        fprintf(stderr, "f\n");
        y->pai = z->pai;
        y->dir = z->dir;
        if(y->dir != NULL)
            y->dir->pai = y;
        y->cor = z->cor;

        if (y->pai == z && x != NULL)  
            x->pai = y;
    }


    if(y_cor_orig == BLACK)
        remover_fixup(t, x);

    free(z);
}
